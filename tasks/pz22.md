## Практическое занятие №22. Разграничение прав доступа в ОС Ubuntu ##

### Ход работы ###
> **Обратите внимание на пункты 3, 7, 9, 10. Не забудьте сделать скриншоты по выполнении этих заданий и показать их преподователю.**

1. Вернуть сеть NAT на ВМ ubuntu.
1. Создать пользователя по шаблону surname, где surname - ваша фамилия.   Войти под этим пользователем в графическом режиме. Создание пользователя производить с помощью команды `adduser` ~~`useradd`~~    
Обе команды создают нового пользователя в системе. Чтобы в будущем стать "успешными" и не упасть в грязь лицом, необходимо усвоить сейчас:
    - Adduser - утилита для добавления пользователей и групп с систему. Программа учитывает политики дистрибутива по желаемому UID и GID, создает домашний каталог, копирует туда файлы по умолчанию и запускает специальные сценарии.
    - Useradd - это низкоуровневая утилита для добавления пользователей. Создается только пользователь без каких-либо дополнительных настроек, вам придется все делать вручную, в том числе создавать домашний каталог.
    > Поэтому рекомендуется использовать `adduser`

1. Добавить пользователя surname в sudo-пользователи. Для добавления пользователя Surname в sudo-пользователи с использованием `usermod` выполните команду
    ```bash
    usermod -a -G sudo surname
    ```
    Флаг `-a` добавляет пользователя в дополнительную группу, используется только с флагом `-G`.
    >Для всего остального есть `man usermod`

	После этого пользователю необходимо перезайти в систему (обязательно через logout, иначе может не сработать), и он сможет пользоваться привелегиями `sudo`  
    **Сделать скриншот вывода `cat /etc/passwd | grep surname`**

1. Создать в /home каталог dir. Владельцем назначить surname. Группу-владельца задать как группу user. Выяснить, что значат права rwx для каталога.

    К середине третьего курса уже точно необходимо разобраться с правами доступа к файлам и каталогам, а также такими "загадочными" командами, как: `chmod`, `chown`, `chgrp`  
	Перейдите в корневую директорию и выполните команду `ls -l`.
	Результат выполнения должен быть вам известен. Но сейчас стоит обратить внимание на цепочку символов `-rwxr-xr-x`, которая у вас может отличаться, но иметь такую же структуру.
	Эти символы можно условно разделить на 4 группы:
    * Первая группа, состоящая из единственного символа, определяет тип файла.
        * — = обычный файл;
        * d = каталог;
        * b = файл блочного устройства;
        * c = файл символьного устройства;
        * s = доменное гнездо (socket);
        * p = именованный канал (pipe);
        * l = символическая ссылка (link).
    * Далее следуют три группы по три символа, которые и определяют права доступа к файлу соответственно для владельца файла(2), для группы пользователей(3), которая сопоставлена данному файлу, и для всех остальных пользователей системы(4).
    Рассмотрим подробнее, что значат условные значения флагов прав:
        * --- = нет прав, совсем;
        * --x = разрешено только выполнение файла, как программы но не изменение и не чтение;
        * -w- = разрешена только запись и изменение файла;
        * r-- = права только на чтение;
        * --s = установлен SUID или SGID бит, первый отображается в поле для владельца, второй для группы;
        * --t = установлен sticky-bit, а значит пользователи не могут удалить этот файл.

	Некоторые пункты могли вызвать у вас недоумение, но не спешите расстраиваться, сейчас вы всё узнаете, если не знали этих вещей ранее.
    #### Специальные права доступа к файлам в LINUX ####
    * SUID = (Set User ID, установить идентификатор пользователя) - процесс, выполняющий файл, в нормальной ситуации сохраняет идентификатор пользователя, которому он принадлежит. Однако если у исполняемого файла установлен флаг suid, процесс получает идентификатор пользователя, владеющего файлом;
    * SGID = (Set Group ID, установить идентификатор группы) - процесс, выполняющий файл, сохраняет идентификатор группы пользователя, которому он принадлежит. Однако если у исполняемого файла установлен флаг sgid, процесс получает идентификатор группы файла;
    * Sticky-bit - выполнимый файл с установленным флагом sticky соответствует запросу к ядру с требованием оставить программу в памяти после окончания ее работы. Установка sticky для каталога запрещает удаление и переименование файлов в каталоге всем (даже имеющим права на изменение    каталога), за исключением root и владельца файла. Сегодня sticky bit используется в основном для каталогов, чтобы защитить в них файлы. Примером может служить каталог /tmp, в который запись открыта для всех пользователей, но нежелательно удаление чужих файлов.
	#### Команды управления правами ####
    * chmod  
	Синтаксис команды:
	```bash
	chmod [OPTIONS] [PERMISSIONS] FILE
    ```
	Восьмеричное значение прав (для эффективной работы их необходимо просто запомнить):
        * 0 - никаких прав;
        * 1 - только выполнение;
        * 2 - только запись;
        * 3 - выполнение и запись;
        * 4 -  только чтение;
        * 5 - чтение и выполнение;
        * 6 - чтение и запись;
        * 7 - чтение запись и выполнение.

	Категории пользователей:
        * u - владелец файла;
        * g - участники группы файла;
        * o - все остальные пользователи.

	Примеры (в начале команды не забудьте дописать chmod):
    	* 755 - все для владельца, остальным только чтение и выполнение;
    	* 764 - все для владельца, чтение и запись для группы, и только чтение для остальных;
        * u+x - разрешить выполнение для владельца;
        * ugo+x - разрешить выполнение для всех;
        * ug+w - разрешить запись для владельца и группы;
        * o-x - запретить выполнение для остальных пользователей;
        * ugo+rwx - разрешить все для всех.
        > Команды вводятся без пробелов между правами и категориями пользователей!!!

    * chown  
	Синтаксис команды:
	```bash
	chown [OPTIONS] USER:GROUP FILE
    ```
	* USER - имя пользователя или идентификатор пользователя (UID) нового владельца;
    * GROUP - имя новой группы или идентификатор группы (GID);
    * FILE - имя одного или нескольких файлов, каталогов или ссылок.  
	Как изменить владельца и группу файла:
	```bash
	chown USER:GROUP FILE
    ```
	Как изменить группу файла:
	```bash
	chown :GROUP FILE
    ```
	Команда chown может выполнять ту же функцию, что и команда chgrp, которую мы рассмотрим далее.
    * chgrp  
	Данная команда изменяет группу каждого заданного файла на группу, которая может быть представлена как именем группы, так и ее числовым идентификатором (GID).
	Синтаксис команды:
	```bash
	chgrp [OPTIONS] [GROUP] FILE
    ```
	Для того, чтобы сменить группу владельцев директории, а также всех находящихся в ней файлов и директорий, достаточно задействовать параметр -R.
1. Найти исполняемый файл для команды ping. Определить права доступа на этот файл. В этом вам поможет команда `which`.
1. Выяснить права на каталог /tmp.
1. В /home/dir/ создать who.c, который должен содержать:
    ```c
    #include <stdio.h>
    #include <unistd.h>

    int main()
    {
        print("surname\n", );
    	printf("UID=%d, but effective UID=%d\n", getuid(), geteuid());
    	return 0;
    }
    ```
    Скомпилировать этот файл с помощью

    ```bash
    gcc -o who who.c
    ```
    С помощью SUID-бита сделать так, чтобы запуск WHO выводил на экран id вашего пользователя, а эффективный id - пользователя root.  
    **Сделать скриншот, на котором будет видны: surname, UID и EUID**
1. Создать исполняемый файл, который ведёт себя как фоновый процесс (демон в терминологии Linux-систем). Для этого при старте этого процесса необходимо создавать так называемый .pid файл - файл, в который записывается PID запущенного процесса. При старте необходимо проверять, есть ли .pid файл, если есть - проверять наличие процесса с указанным pid. Если такой процесс уже существует, то писать об этом в стандартный поток ошибок и завершаться. Если .pid файла нет, либо нет указанного процесса, то стартовать как фоновый процесс, записывая в .pid файл свой PID.
1. Рассмотрим подробнее правильный порядок изменения сетевого имени компьютера. Необходимо внести изменения в три места

    ```bash
    #выводит текущее сетевое имя
    hostname
    # изменяет текущее сетевое имя
    sudo hostname Surname
    # изменяет сетевое имя, которое будет выставлено после перезагрузки
    sudo nano /etc/hostname
    # изменяет сетевое имя для адреся 127.0.0.1, то есть localhost
    sudo nano /etc/hosts
    ```
    **Сделать скриншот, демонстрирующий полную смену hostname**
1. Разобраться с командой zip. Заархивируйте с различным уровнем сжатия короткий текст (100 символов), длинный текст (10к символов), картинку (возьмите любые фото с хостовой или гостевой ОС, в крайнем случае сделайте скриншот Рабочего стола и используйте его).  
    Синтаксис команды:
    ```bash
    zip [OPTIONS] ZIP_FILE FILE
    ```  
    [OPTIONS]:
    - r (recurse) — рекурсивное создание архива
    - s (size) — разбивка архива на определенный размер k (kB), m (MB), g (GB) или t (TB)
    - P (password) — запаролировать архив  (можно использовать ключ e тогда пароль будете вводить в отдельной строке со звездочками )
    - 1-9 — степень сжатия (где 1 без сжатия, а 9 лучшее сжатие; default - 6)  
    С созданием текстов вам может помочь следующий код (string.py):
    ```python
    from random import choice
    from string import ascii_letters
    #100 = количество символов, подлежит изменению
    print(''.join(choice(ascii_letters) for _ in range(int(100))))
    ```
    Для запуска программы используйте команду
    ```bash
    python3 string.py > _.txt
    ```
    >Но вы можете и ручками Ctrl+C->Ctrl+V по 10 символов, вам никто не запрещает:3  

    Создав архивы с именами `surname_short` и `surname_long`, сравните их размеры с исходными текстами, **сделайте скриншот**.
1. Разобраться с командой tar. Получите архив формата .tar.gz, заархивировав некоторый каталог.  
    `tar` — наиболее распространенный архиватор, используемый в Linux-системах. Сам по себе tar не является архиватором в привычном понимании этого слова, т.к. он самостоятельно не использует сжатие. многие архиваторы (например, Gzip или bzip2) не умеют сжимать несколько файлов, а работают только с одним файлом или входным потоком. Поэтому чаще всего эти программы используются вместе: tar создает несжатый архив, в который помещаются выбранные файлы и каталоги, при этом сохраняя некоторые их атрибуты (такие как права доступа). После этого полученный файл `*.tar` сжимается архиватором, например, gzip. Вот почему архивы могут иметь расширение `.tar.gz.`  
    Следует отличать архивирование и сжатие. Это совсем разные понятия:
    - Архивирование - объединение нескольких файлов в один файл. При этом финальный файл может иметь суммарный размер архивированных файлов либо даже больше. Это связано с добавлением служебной информации.
    - Сжатие - уменьшение размера исходного файла.  
    Эта команда упакует все файлы с расширением txt в архив txt.tar:
    ```bash
    tar -cf txt.tar *.txt
    ```
    А эта уже, соответственно, сожмёт архив:
    ```bash
    tar -cvzf files.tar.gz ~/files
    ```
