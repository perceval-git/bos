## Практическое занятие №22. Разграничение прав доступа в ОС Ubuntu ##

### Рассматриваемые вопросы ###
1. Создание и работа с заданными характеристиками пользователя.
1. Права доступа/процесса. Специальные и эффективные права. Управление правами.
1. Смена сетевого имени.
1. Архивирование VS Сжатие.

### Термины, которые нужно усвоить ###
1. `adduser`
1. `usermod`
1. `chmod`, `chown`, `chgrp`
1. UID, GID, SUID, SGID, Sticky-bit
1. hostname
1. `.zip`, `.tar.gz`
1. /dev/zero, /dev/null

### Отчёт по пз ###
> Для справки  
("3-05-1 Иванов passwd"):
- 3 - номер группы
- 05 - порядковый номер, взятый из вашего fullname
- 1 - порядковый номер скриншота
- Иванов - ваша фамимлия
- passwd - индивидуальное имя скриншота

__Скриншот 1__. Сделать скриншот вывода `cat /etc/passwd | grep surname`. ("3-05-1 Иванов passwd")  
__Скриншот 2__. Сделать скриншот запуска и результата работы программы из пункта 7. ("3-05-2 Иванов euid")  
__Скриншот 3__. Сделать скриншот последовательного выполнения команд: `hostname`, `sudo cat /etc/hostname`, `sudo cat /etc/hosts`. ("3-05-3 Иванов hostname")  
__Скриншот 4__. Сделать скриншот вывода `ls -la` каталога "bos22_fullname". ("3-05-4 Иванов zip")

> На заметку: везде, где есть surname, его __нужно изменять на свою фамилию__  
Задание данного ПЗ настолько же большое, насколько интересное. Поэтому просиживать штаны настоятельно __не рекомендуется__.

### Ход работы ###
> **Обратите внимание на пункты 3, 7, 9, 10. Не забудьте сделать скриншоты по выполнении этих заданий и показать их преподователю.**

1. Вернуть сеть NAT на ВМ ubuntu.
1. Создать пользователя по шаблону surname, где surname - ваша фамилия.   Войти под этим пользователем в графическом режиме. Создание пользователя производить с помощью команды `adduser` ~~`useradd`~~    
Обе команды создают нового пользователя в системе. Чтобы в будущем стать "успешными" и не упасть в грязь лицом, необходимо усвоить сейчас:
    - Adduser - утилита для добавления пользователей и групп с систему. Программа учитывает политики дистрибутива по желаемому UID и GID, создает домашний каталог, копирует туда файлы по умолчанию и запускает специальные сценарии.
    - Useradd - это низкоуровневая утилита для добавления пользователей. Создается только пользователь без каких-либо дополнительных настроек, вам придется все делать вручную, в том числе создавать домашний каталог.
    > Поэтому рекомендуется использовать `adduser`

1. Добавить пользователя surname в sudo-пользователи. Для добавления пользователя Surname в sudo-пользователи с использованием `usermod` выполните команду
    ```bash
    usermod -a -G sudo surname
    ```
    Флаг `-a` добавляет пользователя в дополнительную группу, используется только с флагом `-G`.
    >"Для всего остального есть ~~`mastercard`~~ `man usermod`"

	После этого пользователю необходимо перезайти в систему (обязательно через logout, иначе может не сработать), и он сможет пользоваться привелегиями `sudo`  
    **Сделать скриншот вывода `cat /etc/passwd | grep surname`**

1. Создать в /home каталог dir. Владельцем назначить surname. Группу-владельца задать как группу user. Выяснить, что значат права rwx для каталога.

    К середине третьего курса уже точно необходимо разобраться с правами доступа к файлам и каталогам, а также такими "загадочными" командами, как: `chmod`, `chown`, `chgrp`  
	Перейдите в корневую директорию и выполните команду `ls -l`.
	Результат выполнения должен быть вам известен. Но сейчас стоит обратить внимание на цепочку символов `-rwxr-xr-x`, которая у вас может отличаться, но иметь такую же структуру.
	Эти символы можно условно разделить на 4 группы:
    * Первая группа, состоящая из единственного символа, определяет тип файла.
        * — = обычный файл;
        * d = каталог;
        * b = файл блочного устройства;
        * c = файл символьного устройства;
        * s = доменное гнездо (socket);
        * p = именованный канал (pipe);
        * l = символическая ссылка (link).
    * Далее следуют три группы по три символа, которые и определяют права доступа к файлу соответственно для владельца файла(2), для группы пользователей(3), которая сопоставлена данному файлу, и для всех остальных пользователей системы(4).
    Рассмотрим подробнее, что значат условные значения флагов прав:
        * --- = нет прав, совсем;
        * --x = разрешено только выполнение файла, как программы но не изменение и не чтение;
        * -w- = разрешена только запись и изменение файла;
        * r-- = права только на чтение;
        * --s = установлен SUID или SGID бит, первый отображается в поле для владельца, второй для группы;
        * --t = установлен sticky-bit, а значит пользователи не могут удалить этот файл.

	Некоторые пункты могли вызвать у вас недоумение, но не спешите расстраиваться, сейчас вы всё узнаете, если не знали этих вещей ранее.
    ### Эффективные права процесса ####
    С каждым процессом Unix связаны два атрибута UID и GID - пользователь и основная группа. В принципе, они могли бы определять права доступа процесса к ФС и другим процессам, однако существует несколько ситуаций, когда права процесса отличаются от прав его владельца. Поэтому кроме UID/GID (иногда называемых реальными RUID/RGID) с процессом связаны атрибуты прав доступа - эффективные UID/GID - EUID/EGID, чаще всего совпадающие с RUID/RGID.  
    EUID/EGID и список групп определяют права доступа процесса к ФС. Вновь создаваемые файлы наследуют атрибуты UID/GID от EUID/EGID процесса. Кроме того EUID определяет права доступа к другим процессам (отладка, отправка сигналов и т.п.). Процесс с EUID=0 всегда имеет право на чтение и запись файлов и каталогов. Право на выполнение файлов предоставляется привилегированному процессу только в том случае, когда у файла выставлен хотя бы один атрибут права на исполнение.  
    А теперь поговрим о каждом из них поподробнее:
    1. UID (User ID)  
    UID обозначает идентификатор пользователя. UID – это номер, назначенный каждому пользователю Linux. Это представление пользователя в ядре Linux.
    UID используется для идентификации пользователя в системе и для определения того, к каким системным ресурсам пользователь может получить доступ. Вот почему идентификатор пользователя должен быть уникальным.  
    В большинстве дистрибутивов Linux UID 1-500 обычно зарезервирован для системных пользователей. В Ubuntu и Fedora UID для новых пользователей начинаются с 1000.
    1. GID (Group ID)  
    Кроме идентификационного номера пользователя с учётной записью связан идентификатор группы. Группы пользователей применяются для организации доступа нескольких пользователей к некоторым ресурсам. В Linux каждый пользователь должен принадлежать как минимум к одной группе — группе по умолчанию. При создании учётной записи пользователя обычно создаётся и группа, имя которой совпадает с созданным именем пользователя, именно эта группа будет использоваться как группа по умолчанию для этого пользователя. Пользователь может входить более чем в одну группу, но в учётной записи указывается только номер группы по умолчанию. Группы позволяют регулировать доступ нескольких пользователей к различным ресурсам.
    > Команда `id` в Linux отобразит UID, GID и группы, к которым принадлежит ваш текущий пользователь

    3. EUID/GUID (Effective UID/GUID)  
    По умолчанию EUID и EGID также будут равны UID и GID пользователя, запустившего процесс. Однако, если для файла установлены биты SUID или SGID, то EUID и EGID будут равны UID и GID владельца-пользователя и владельца-группы соответственно. Эффективный идентификатор служит для определения прав доступа процесса к системным ресурсам (в первую очередь к ресурсам файловой системы).
    В подавляющем большинстве случаев подмена владельца или группы осуществляется на root или какого-либо привилегированного пользователя или
    группу. Например, при выполнении команды `ping`, несмотря на то, что ее запустил обычный пользователь, она будет исполняться от имени root, т.к. он владеет ее исполняемым файлом.  
    Также в качестве примера можно привести утилиту `passwd`, владельцем которой является root, и у нее установлен бит SUID. Это дает право любому пользователю изменять свой пароль и сохранить изменения в файле паролей.  
    Стоит также отметить, что в любом случае утилита passwd может по битам RUID и EUID определить, запустил ее суперпользователь, либо другой пользователь от имени суперпользователя. И, соответственно, для обычных пользователей она может предоставить лишь ограниченные права. Например, суперпользователь может изменять пароль любого пользователя, даже не зная его старого пароля. При запуске дочерних процессов они наследуют права доступа родительского процесса. Поэтому устанавливать биты SUID и SGID следует __с большой осторожностью__ и только для программ, которые не имеют возможности запуска произвольных задач, поскольку, например, командный интерпретатор, запущенный от имени суперпользователя, предоставляет почти неограниченные возможности.

    #### Специальные права доступа к файлам в LINUX ####
    * SUID = (Set User ID, установить идентификатор пользователя) - процесс, выполняющий файл, в нормальной ситуации сохраняет идентификатор пользователя, которому он принадлежит. Однако если у исполняемого файла установлен флаг suid, процесс получает идентификатор пользователя, владеющего файлом;
    * SGID = (Set Group ID, установить идентификатор группы) - процесс, выполняющий файл, сохраняет идентификатор группы пользователя, которому он принадлежит. Однако если у исполняемого файла установлен флаг sgid, процесс получает идентификатор группы файла;
    * Sticky-bit - выполнимый файл с установленным флагом sticky соответствует запросу к ядру с требованием оставить программу в памяти после окончания ее работы. Установка sticky для каталога запрещает удаление и переименование файлов в каталоге всем (даже имеющим права на изменение    каталога), за исключением root и владельца файла. Сегодня sticky bit используется в основном для каталогов, чтобы защитить в них файлы. Примером может служить каталог /tmp, в который запись открыта для всех пользователей, но нежелательно удаление чужих файлов.  
    Как оно в теории - мы узнали, теперь посмотрим на практике, кто же такие __sticky-bit__ и SUID.  
    Найдем программы с SUID с помощью команды:
    ```bash
    ls -la /usr/bin | grep rws
    ```
    В список выведенных команд войдет и вышеупомянутая `passwd`.  
    Для поиска каталогов с установенным sticky-bit можно воспользоваться двумя командами:
    ```bash
    ls -la / | grep rwt
    ```
    ```bash
    sudo find / -perm -1000 -print
    ```
    Здесь 1000 - восьмиричное значение sticky-bit
    > Эту команду можно выполнить и для SUID/SGID тоже. Для них восьмиричные значения - 4000 и 2000 соответственно.

	#### Команды управления правами ####
    * chmod  
	Синтаксис команды:
	```bash
	chmod [OPTIONS] [PERMISSIONS] FILE
    ```
	Восьмеричное значение прав (для эффективной работы их необходимо просто запомнить):
        * 0 - никаких прав;
        * 1 - только выполнение;
        * 2 - только запись;
        * 3 - выполнение и запись;
        * 4 -  только чтение;
        * 5 - чтение и выполнение;
        * 6 - чтение и запись;
        * 7 - чтение запись и выполнение.

	Категории пользователей:
        * u - владелец файла;
        * g - участники группы файла;
        * o - все остальные пользователи.

	Примеры (в начале команды не забудьте дописать chmod):
    	* 755 - все для владельца, остальным только чтение и выполнение;
    	* 764 - все для владельца, чтение и запись для группы, и только чтение для остальных;
        * u+x - разрешить выполнение для владельца;
        * ugo+x - разрешить выполнение для всех;
        * ug+w - разрешить запись для владельца и группы;
        * o-x - запретить выполнение для остальных пользователей;
        * ugo+rwx - разрешить все для всех.
        > Команды вводятся без пробелов между правами и категориями пользователей!!!

    * chown  
	Синтаксис команды:
	```bash
	chown [OPTIONS] USER:GROUP FILE
    ```
	* USER - имя пользователя или идентификатор пользователя (UID) нового владельца;
    * GROUP - имя новой группы или идентификатор группы (GID);
    * FILE - имя одного или нескольких файлов, каталогов или ссылок.  
	Как изменить владельца и группу файла:
	```bash
	chown USER:GROUP FILE
    ```
	Как изменить группу файла:
	```bash
	chown :GROUP FILE
    ```
	Команда chown может выполнять ту же функцию, что и команда chgrp, которую мы рассмотрим далее.
    * chgrp  
	Данная команда изменяет группу каждого заданного файла на группу, которая может быть представлена как именем группы, так и ее числовым идентификатором (GID).
	Синтаксис команды:
	```bash
	chgrp [OPTIONS] [GROUP] FILE
    ```
	Для того, чтобы сменить группу владельцев директории, а также всех находящихся в ней файлов и директорий, достаточно задействовать параметр -R.
1. Найти исполняемый файл для команды ping. Определить права доступа на этот файл. В этом вам поможет команда `which`:
    ```bash
    which ping
    ```
    Выводом послужит путь до местоположения `ping` в системе, поэтому следующиим шагом будет:
    ```bash
    ls -la /bin | grep ping
    ```    
1. Выяснить права на каталог /tmp.
1. В /home/dir/ создать who.c, который должен содержать:
    ```c
    #include <stdio.h>
    #include <unistd.h>

    int main()
    {
        print("surname\n", );
    	printf("UID=%d, but effective UID=%d\n", getuid(), geteuid());
    	return 0;
    }
    ```
    Скомпилировать этот файл с помощью

    ```bash
    gcc -o who who.c
    ```
    С помощью SUID-бита сделать так, чтобы запуск WHO выводил на экран id вашего пользователя, а эффективный id - пользователя root.

    **Сделать скриншот, на котором будет видны: surname, UID и EUID**
1. Рассмотрим подробнее правильный порядок изменения сетевого имени компьютера. Необходимо внести изменения в три места

    ```bash
    #выводит текущее сетевое имя
    hostname
    # изменяет текущее сетевое имя
    sudo hostname surname
    # удалить старое сетевое имя, вписать на его место новое
    sudo nano /etc/hostname
    # изменить сетевое имя для адреса 127.0.0.1, то есть localhost
    sudo nano /etc/hosts
    ```
    Столь сложную смену сетевого имени в трех местах сразу приходиться делать не просто так. Одна команда `sudo hostname surname` установит сетевое имя компьютера, которое сохранится __только до перезагрузки__. Для того, чтобы сделать изменения постоянными, необходимо вписать новое сетевое имя еще в файлы /etc/hostname и /etc/hosts.
    Теперь нужно перезагрузить систему.  
    >А можно прочитать дальше и узнать, что можно обойтись и без этого: ` systemctl restart systemd-logind.service`. Команда просто перезагрузит сервис управления входом пользователей.

    **Сделать скриншот, демонстрирующий полную смену hostname**
1. Пришла пора узнать про __архивирование__ и __сжатие__, понять кто из них есть кто. Следует отличать архивирование и сжатие. Это совсем разные понятия:
    - Архивирование - объединение нескольких файлов в один файл. При этом финальный файл может иметь суммарный размер архивированных файлов либо даже больше. Это связано с добавлением служебной информации.
    - Сжатие - уменьшение размера исходного файла.  

    У архивации есть еще одно замечательное свойство. По-простому его можно назвать «упаковка». Оно заключается в возможности создать архив без сжатия файлов. Целью упаковки файлов обычно являются обеспечение более компактного размещения информации на диске, сокращение времени и, соответственно, стоимости передачи информации по каналам связи в компьютерных сетях. Кроме того, упаковка в один архивный файл группы файлов существенно упрощает их перенос с одного компьютера на другой, сокращает время копирования файлов на диски, позволяет защитить информацию от несанкционированного доступа, способствует защите от заражения компьютерными вирусами.
    Также существует такое понятие, как степень сжатия. Под степенью сжатия понимают отношение размеров сжатого файла и исходного, выраженное в процентах. Степень сжатия зависит от используемой программы сжатия, метода сжатия и типа исходного файла. Лучше всего сжимаются файлы графических образов, текстовые файлы, файлы данных, степень сжатия которых может достигать 5 — 40%, меньше сжимаются файлы исполняемых программ и загрузочных модулей — 60 — 90%. Почти не сжимаются архивные файлы. Программы для архивации отличаются используемыми методами сжатия, что соответственно влияет на степень сжатия.
    Все алгоритмы сжатия данных качественно делятся на:
    - алгоритмы сжатия без потерь, при использовании которых данные восстанавливаются без малейших изменений
    - алгоритмы сжатия с потерями, которые удаляют из потока данных информацию, незначительно влияющую на суть данных, либо вообще не воспринимаемую человеком (такие алгоритмы сейчас разработаны только для аудио- и видеоизображений). В криптосистемах, естественно, используется только первая группа алгоритмов.  
    Существуют два основных метода архивации без потерь:
    1. алгоритм Хаффмана, ориентированный на сжатие последовательностей байт, не связанных между собой,
    1. алгоритм Лемпеля-Зива, ориентированный на сжатие любых видов текстов, то есть использующий факт неоднократного повторения "слов" – последовательностей байт.  
    Практически все популярные программы архивации без потерь (ARJ, RAR, ZIP и т.п.) используют объединение этих двух методов – алгоритм LZH.
    > __Справка по сжатию с потерями:__  

    Сжатие с потерями применяется в основном для графики (JPEG), звука (MP3), видео (MPEG), то есть там, где в силу огромных размеров файлов степень сжатия очень важна, и можно пожертвовать деталями, не существенными для восприятия этой информации человеком. Особые возможности для сжатия информации имеются при компрессии видео. В ряде случаев большая часть изображения передается из кадра в кадр без изменений, что позволяет строить алгоритмы сжатия на основе выборочного отслеживания только части «картинки». В частном случае изображение говорящего человека, не меняющего своего положения, может обновляться только в области лица или даже только рта — то есть в той части, где происходят наиболее быстрые изменения от кадра к кадру.  
    В целом ряде случаев сжатие графики с потерями, обеспечивая очень высокие степени компрессии, практически незаметно для человека. Однако методы сжатия с потерями обладают и рядом недостатков:  

    Первый заключается в том, что компрессия с потерями применима не для всех случаев анализа графической информации. Например, если в результате сжатия изображения на лице изменится форма родинки (но лицо при этом останется полностью узнаваемо), то эта фотография окажется вполне приемлемой, чтобы послать ее по почте знакомым, однако если пересылается фотоснимок легких на медэкспертизу для анализа формы затемнения — это уже совсем другое дело. Кроме того, в случае машинных методов анализа графической информации результаты кодирования с потерей (незаметные для глаз) могут быть «заметны» для машинного анализатора.  
    Вторая причина заключается в том, что повторная компрессия и декомпрессия с потерями приводят к эффекту накопления погрешностей. Если говорить о степени применимости формата JPEG, то, очевидно, он полезен там, где важен большой коэффициент сжатия при сохранении исходной цветовой глубины. Именно это свойство обусловило широкое применение данного формата в представлении графической информации в Интернете, где скорость отображения файла (его размер) имеет первостепенное значение. Отрицательное свойство формата JPEG — ухудшение качества изображения, что делает практически невозможным его применение в полиграфии, где этот параметр является определяющим.  
    ____________________________________________________________________________
    Разобраться с командой zip. Заархивируйте с различным уровнем сжатия короткий текст (100 символов), длинный текст (10к символов), картинку (возьмите любые фото с хостовой или гостевой ОС, в крайнем случае сделайте скриншот Рабочего стола и используйте его).  
    С созданием текстов вам может помочь следующий код (string.py):
    ```python
    from random import choice
    from string import ascii_letters
    #100 = количество символов, подлежит изменению
    print(''.join(choice(ascii_letters) for _ in range(int(100))))
    ```
    Для запуска программы используйте команду
    ```bash
    python3 string.py > _.txt
    ```
    >Но вы можете и ручками Ctrl+C->Ctrl+V по 10 символов, вам никто не запрещает:3  

    Результат этого пункта нужно зафиксировать на скриншоте. Чтобы ваш скриншот был наглядным, и к вам не возникло вопросов, создайте каталог __bos22_fullname__, внутри которого в ближайшем будущем появятся файлы для архивации, а также сами архивы.
    Итого, на вашем выводе `ls -la` должно быть видно, что вы находитесь или перешли в каталог "bos22_fullname", в котором лежит 6 файлов: `surname_short.txt`, `surname_long.txt`, `surname_picture` и zip-архив каждого из этих файлов, подписанный соответсвующим образом.

    Синтаксис команды:
    ```bash
    zip [OPTIONS] ZIP_FILE FILE
    ```  
    [OPTIONS]:
    - r (recurse) — рекурсивное создание архива
    - s (size) — разбивка архива на определенный размер k (kB), m (MB), g (GB) или t (TB)
    - P (password) — запаролировать архив  (можно использовать ключ e тогда пароль будете вводить в отдельной строке со звездочками)
    - x "/var/log/apt/* " — позволяет исключить указанную папку или файл из архива
    - 1-9 — степень сжатия (6 - default, 0 - без сжатия)
1. Разобраться с командой tar. Получите архив формата .tar.gz, заархивировав некоторый каталог.  
    `tar` — наиболее распространенный архиватор, используемый в Linux-системах. Сам по себе tar не является архиватором в привычном понимании этого слова, т.к. он самостоятельно не использует сжатие. многие архиваторы (например, gzip или bzip2) не умеют сжимать несколько файлов, а работают только с одним файлом или входным потоком. Поэтому чаще всего эти программы используются вместе: tar создает несжатый архив, в который помещаются выбранные файлы и каталоги, при этом сохраняя некоторые их атрибуты (такие как права доступа). После этого полученный файл `*.tar` сжимается архиватором, например, gzip. Вот почему архивы могут иметь расширение `.tar.gz.`  
    Эта команда упакует все файлы с расширением txt в архив txt.tar:
    ```bash
    tar -cf txt.tar *.txt
    ```
    А эта уже, соответственно, сожмёт архив:
    ```bash
    tar -cvzf files.tar.gz ~/files
    ```
    > Можете не дочитывать, но __именно вас спросят именно об этом__ :3

    #### /dev/zero и /dev/null ####
    1. /dev/zero — специальный файл в UNIX-подобных системах, представляющий собой источник нулевых байтов (ASCII NUL, 0x00). При чтении этого файла никогда не достигается его конец.  
    Любые данные, записанные в /dev/zero, будут игнорированы, а сама запись завершается успешно — точно так же, как и при записи в /dev/null (хотя последнее намного чаще используется как «чёрная дыра», чем /dev/zero).
    1. Устройство /dev/zero считается символьным. В Linux оно создаётся с помощью утилиты `mknod` следующим образом:
    ```bash
    mknod FILE c 1 5
    ```
    Здесь FILE — имя для нового устройства. На этапе установки системы оно создаётся таким образом со стандартным именем /dev/zero.
    1. Чаще всего /dev/zero используется для создания файла заданного размера (например, для размещения там образа файловой системы). Например, для создания файла image.iso размером 100 кБ можно выполнить команду:
    ```bash
    dd if=/dev/zero of=image.iso bs=1024 count=100
    ```
    /dev/zero можно использовать как источник информации для перезаписи устройств и файлов - если есть необходимость затереть все данные на диске.  
    1. /dev/null — специальный файл в системах класса UNIX, представляющий собой так называемое «пустое устройство». Запись в него происходит успешно, независимо от объёма «записанной» информации. Чтение из /dev/null эквивалентно считыванию конца файла (EOF).
    1. Устройство /dev/null также считается символьным и тоже создается с помощью утилиты `mknod`
    ```bash
    mknod FILE c 1 3
    ```
    1. Чаще всего перенаправление в /dev/null используется для подавления стандартного вывода (выходного потока) и/или вывода сообщений об ошибках (потока диагностики) программы их перенаправлением в /dev/null, такое подавление чаще всего используется в командных сценариях (shell scripts) для подавления нежелательного вывода на консоль.  
    Вывод потока стандартного вывода (STDOUT) и потока ошибок (STDERR) в /dev/null:
    ```bash
    do something > /dev/null 2>&1
    ```
    В современных оболочках bash для перенаправления стандартного вывода (STDOUT) и потока ошибок (STDERR) в /dev/null рекомендуется применять:
    ```bash
    do something &> /dev/null
    ```
    > Напоминаю:  &>file или >&file - направить стандартный поток вывода и стандартный поток ошибок в файл. Другая форма записи: >file 2>&1
